def solution(routes):

    routes.sort()

    speed_trap_position = routes[0][1]

    cnt = 1
    for i in range(1, len(routes)):
        if speed_trap_position > routes[i][1]:
            speed_trap_position = routes[i][1]
        elif speed_trap_position < routes[i][0]:
            cnt += 1
            speed_trap_position = routes[i][1]
        elif routes[i][0] < speed_trap_position < routes[i][1] or speed_trap_position == routes[i][0]:
            continue

    return cnt


print(solution([[-20, -15], [-14, -5], [-18, -13], [-5, -3]]))
print(solution([[-2, -1], [-4, -3], [-20, -15], [-14, -5], [-18, -13], [-5, -3]]))
print(solution([[-14, -11], [-11, -9], [-10, -6], [-8, -3], [-6, -4], [-5, -3]]))


# 설명
# 모든 경로의 자동차가 단속 카메라에 찍히려면 카메라가 최소 몇 대가 있어야하는지 구해야한다.
# 출발지점 기준으로 정렬하면 두번째 경로는 첫번째 경로의 출발지점보다는 늦게 출발한 지점이 된다.
# 하지만 두번째 도착지점이 첫번째 도착지점보다 무조건 더 뒤에 있다고는 할 수도 없다.

# 1. 첫번째 경로의 범위 안에 두번째 경로의 출발, 도착 지점이 있는 경우
# -> 이 경우는 두번째 경로가 첫번째 경로의 범위 안에 있기 때문에 카메라의 위치를 두번째 경로의 도착지점으로 이동해야 카메라가 둘 다 찍을 수 있기 때문에 이동해준다.

# 2. 첫번째 경로의 범위 밖에 두번째 경로의 출발, 도착 지점이 있는 경우
# -> 이 경우는 두번째 경로가 첫번째 경로의 범위 밖에 있기 때문에 카메라를 1대 증가시키고 카메라의 위치를 두번째 경로 도착지점으로 이동해준다.

# 3-1. 두번째 출발지점 < 첫번째 도착지점 < 두번째 도착지점
# -> 이 경우는 두번째 경로 사이에 카메라의 위치인 첫번째 도착지점이 있기 때문에 현재 위치를 그대로 유지해준다.

# 3-2. 첫번째 도착지점 == 두번째 출발지점
# -> 이 경우는 첫번째 경로의 도착지점과 두번째 경로의 출발지점이 동일한 경우인데 이 문제에서 이 경우도 카메라가 찍을 수 있는 범위에 속하므로 카메라를 이동하지 않아도 된다.
#    여기서 만약 카메라 위치를 두번째 경로의 출발지점으로 이동한다면,
#    다음 세번째 경로의 출발지점은 당연하게도 두번째 경로의 출발지점 보다 더 늦게 출발하기 때문에 카메라가 동시에 찍을 수 없는 위치가 된다.
