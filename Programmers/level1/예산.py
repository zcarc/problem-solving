def solution(d, budget):

    d.sort()

    total = 0

    cnt = 0
    for e in d:
        total += e
        if total <= budget:
            cnt += 1
        else:
            break

    return cnt


print(solution([1, 3, 2, 5, 4], 9))
print(solution([2, 2, 3, 3], 10))


# 해설
# 최대한 많은 부서에게 물건을 구매해주기 위해서 오름차순 정렬을 해야한다.
# 내림차순 정렬을 하면 더 적은 수의 부서에 물건을 구매해줄 수 있다.


# ex 1)
# d = [1, 3, 2, 5, 4], budget = 9

# d를 내림차순으로 정렬하면 [5, 4, 3, 2, 1] 이 된다.
# 여기서 5와 4를 더하면 9가 되어 2개의 부서에 물건을 사줄 수 있게된다.

# d를 오름차순으로 정렬하면 [1, 2, 3, 4, 5] 가 된다.
# 여기서 [1, 3, 5]를 더하면 9가 되어 3개의 부서에 물건을 사줄 수 있게된다.

# [1, 2, 3] = 6 이 되고 다음 금액이 최소 3원부터 시작될 수 있다.
# 다응 금액이 4원이라면
# [1, 2, 3, 4] = 10원이 되어 해당 부서만큼 물품을 구매해줄 수 없다.

# 3원이라면
# [1, 2, 3, 3] = 9원이 되어 해당 부서만큼 물품을 구매해줄 수 있다.

# 문제설명에서는
# [1, 3, 5] = 9 인 경우에 사줄 수 있다고 했는데
# [1, 2, 3] 에서 2 대신 3이 오고, 3 대신 5가 와도 답은 같다.


# ex 2)
# d = [1, 1, 2, 3, 4] budget = 9
# 이 경우에는 다음과 같은 경우일 경우 4개의 부서에 물건을 사줄 수 있는데
# [1, 1, 2, 3] = 7
# [1, 1, 2, 4] = 8
# [1, 1, 3, 4] = 9
# 여기서는 1차원 배열로 순차적으로 탐색하므로 첫번째 케이스인 경우만 평가가 가능하다.
# 하지만 두번째, 세번째 케이스가 올 수도 있다고 가정했을 때,
# 9 - 7 = 2 이므로 더해질 수 있는 수가 최대 2 (1 ~ 2) 가 되므로 두번째, 세번째 케이스 모두 가능하다.

# 이 문제는 오름차순으로 정렬해서 현재 값이 그 전 값과 같거나 그 전 값보다 크다는 특성 때문에 이런 풀이가 가능하다.
